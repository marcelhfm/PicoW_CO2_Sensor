#include "main.h"
#include <FreeRTOS.h>
#include <queue.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <task.h>

#include "hardware/watchdog.h"
#include "i2c/i2c.h"
#include "pico/cyw43_arch.h"
#include "pico/stdio.h"
#include "projdefs.h"
#include "ssd1306/display.h"
#include "ssd1306/ssd1306.h"
#include "tasks/logging.h"
#include "tasks/network_task.h"
#include "tasks/read_data_task.h"
#include "tasks/update_display_task.h"

volatile QueueHandle_t log_queue = NULL;
volatile QueueHandle_t display_queue = NULL;
volatile QueueHandle_t network_queue = NULL;
TaskHandle_t read_data_handle = NULL;
TaskHandle_t update_display_handle = NULL;
TaskHandle_t network_task_handle = NULL;

char *TAG = "MAIN";

bool display_on;

int init_wifi() {
  if (cyw43_arch_init()) {
    DEBUG_LOG("Main: Failed to initialize CYW43\n");
    return -1;
  }

  cyw43_arch_enable_sta_mode();

  DEBUG_LOG("Main: Connecting to WiFi %s and pwd %s\n", WIFI_SSID,
            WIFI_PASSWORD);

  int retry_count = 0;
  while (cyw43_arch_wifi_connect_timeout_ms(
             WIFI_SSID, WIFI_PASSWORD, CYW43_AUTH_WPA2_AES_PSK, 30000) != 0) {
    retry_count++;
    DEBUG_LOG("Main: Failed to connect to WiFi, retrying... (Attempt %d)\n",
              retry_count);
    vTaskDelay(pdMS_TO_TICKS(10000)); // Increase the delay to 10 seconds
    if (retry_count >= 5) {           // Limit retries to avoid infinite loop
      DEBUG_LOG(
          "Main: Exceeded maximum WiFi connection attempts, rebooting...\n");
      watchdog_reboot(0, 0, 0); // Reboot the system
    }
  }

  DEBUG_LOG("Main: Successfully connected to WiFi!\n");
  return 0;
}

int main() {
  stdio_init_all();

  sleep_ms(2000); // Wait for serial_port to be initialized

  if (watchdog_caused_reboot()) {
    DEBUG_LOG("[MAIN] Rebooted by Watchdog!\n");
  } else {
    DEBUG_LOG("[MAIN] Clean boot\n");
  }

  // log_queue = xQueueCreate(LOG_QUEUE_LENGTH, LOG_MESSAGE_MAX_LENGTH);
  // if (log_queue == NULL) {
  //   DEBUG_LOG("Main: Failed to create queue\n");
  //   return -1;
  // }
  //
  init_wifi();

  // Init display
  init_i2c();
  i2c_scan();

  oled_init();

  FrameBuffer fb;
  if (fb_init(&fb) != 0) {
    DEBUG_LOG("update_display_task: Init failed, fb init failed.\n");
    return -1;
  }
  fb_clear(&fb);

  init_udp();
  send_udp_message("1;Testing Message from picow! :)");

  // xTaskCreate(udp_log_task, "UDP Log Task", 1024, NULL, tskIDLE_PRIORITY,
  // NULL);

  enum WriteMode wm = ADD;
  enum Rotation rot = deg0;
  update_display_params ud_params;
  ud_params.fb = &fb;
  ud_params.wm = wm;
  ud_params.rot = rot;
  DEBUG_LOG("main: Creating Tasks\n");
  BaseType_t read_data_status = xTaskCreate(read_data_task, "READ_DATA_TASK",
                                            2056, NULL, 2, &read_data_handle);

  BaseType_t update_display_status =
      xTaskCreate(update_display_task, "UPDATE_DISPLAY_TASK", 4112,
                  (void *)&ud_params, 1, &update_display_handle);

  BaseType_t network_task_status = xTaskCreate(
      network_task, "NETWORK_TASK", 2056, NULL, 1, &network_task_handle);

  DEBUG_LOG("main: Creating queues\n");
  display_queue = xQueueCreate(5, sizeof(int));
  network_queue = xQueueCreate(5, sizeof(measurements_t));

  if (read_data_status == pdPASS && update_display_status == pdPASS &&
      network_task_status == pdPASS) {
    DEBUG_LOG("main: Starting scheduler!\n");
    vTaskStartScheduler();
  } else {
    DEBUG_LOG("main: Unable to start scheduler! RD: %ld UD: %ld",
              read_data_status, update_display_status);
    return -1;
  }
  // should never be reached
  while (1)
    ;
}
